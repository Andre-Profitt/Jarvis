"""
MCP Integrator for JARVIS
=========================

Model Context Protocol integration system for tool deployment.
"""

import asyncio
import json
import subprocess
import shutil
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Any, Optional, Tuple, Set
from pathlib import Path
import yaml
import toml
from jinja2 import Template, Environment, FileSystemLoader
import aiohttp
import websockets
from structlog import get_logger
from prometheus_client import Counter, Histogram, Gauge
import docker
import git
import semantic_version
import hashlib

logger = get_logger(__name__)

# Metrics
mcp_tools_created = Counter("mcp_tools_created_total", "Total MCP tools created")
mcp_deployments = Counter("mcp_deployments_total", "Total MCP deployments", ["status"])
mcp_active_servers = Gauge("mcp_active_servers", "Number of active MCP servers")
deployment_time = Histogram("mcp_deployment_duration_seconds", "MCP deployment time")


@dataclass
class MCPToolSpec:
    """Specification for an MCP tool"""

    name: str
    version: str
    description: str
    author: str
    capabilities: List[str]
    parameters: Dict[str, Any]
    requirements: List[str]
    environment_variables: Dict[str, str] = field(default_factory=dict)
    docker_image: Optional[str] = None
    entry_point: str = "main.py"


@dataclass
class MCPManifest:
    """MCP tool manifest"""

    tool_name: str
    version: str
    protocol_version: str = "1.0"
    description: str = ""
    author: str = ""
    license: str = "MIT"
    repository: Optional[str] = None
    homepage: Optional[str] = None
    keywords: List[str] = field(default_factory=list)
    categories: List[str] = field(default_factory=list)
    capabilities: Dict[str, Any] = field(default_factory=dict)
    dependencies: Dict[str, str] = field(default_factory=dict)
    build_requirements: List[str] = field(default_factory=list)


@dataclass
class MCPDeployment:
    """MCP deployment information"""

    deployment_id: str
    tool_name: str
    version: str
    status: str  # pending, running, stopped, failed
    server_url: Optional[str] = None
    container_id: Optional[str] = None
    pid: Optional[int] = None
    created_at: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class MCPMessage:
    """MCP protocol message"""

    id: str
    method: str
    params: Dict[str, Any]
    timestamp: datetime = field(default_factory=datetime.now)


class MCPIntegrator:
    """
    Model Context Protocol integration system.

    Features:
    - MCP tool creation and packaging
    - Protocol implementation
    - Server deployment
    - Client generation
    - Tool discovery and registry
    - Version management
    - Docker containerization
    - API gateway integration
    """

    def __init__(
        self,
        workspace_path: Path = Path("./mcp_workspace"),
        registry_url: Optional[str] = None,
        docker_enabled: bool = True,
    ):

        self.workspace_path = workspace_path
        self.registry_url = registry_url
        self.docker_enabled = docker_enabled and self._check_docker()

        # Create workspace
        self.workspace_path.mkdir(parents=True, exist_ok=True)

        # Template environment
        self.template_env = self._setup_templates()

        # Docker client
        self.docker_client = docker.from_env() if self.docker_enabled else None

        # Active deployments
        self.deployments: Dict[str, MCPDeployment] = {}

        # WebSocket connections
        self.ws_connections: Dict[str, websockets.WebSocketClientProtocol] = {}

        logger.info(
            "MCP Integrator initialized",
            workspace=str(workspace_path),
            docker_enabled=self.docker_enabled,
        )

    def _check_docker(self) -> bool:
        """Check if Docker is available"""
        try:
            docker.from_env().ping()
            return True
        except:
            logger.warning("Docker not available, containerization disabled")
            return False

    def _setup_templates(self) -> Environment:
        """Setup Jinja2 templates"""
        # Create template directory
        template_dir = self.workspace_path / "templates"
        template_dir.mkdir(exist_ok=True)

        # Create default templates
        self._create_default_templates(template_dir)

        # Setup environment
        env = Environment(loader=FileSystemLoader(str(template_dir)), autoescape=True)

        return env

    def _create_default_templates(self, template_dir: Path):
        """Create default MCP templates"""
        # MCP server template
        server_template = '''#!/usr/bin/env python3
"""
MCP Server for {{ tool_name }}
Generated by JARVIS MCP Integrator
"""

import asyncio
import json
import sys
from typing import Dict, Any, List
import websockets
from datetime import datetime

class {{ tool_name | title | replace(' ', '') }}MCPServer:
    """MCP server implementation for {{ tool_name }}"""
    
    def __init__(self, host: str = "0.0.0.0", port: int = 8765):
        self.host = host
        self.port = port
        self.clients = set()
        self.capabilities = {{ capabilities | tojson }}
    
    async def handle_message(self, websocket, message: Dict[str, Any]) -> Dict[str, Any]:
        """Handle incoming MCP message"""
        method = message.get("method", "")
        params = message.get("params", {})
        
        # Route to appropriate handler
        if method == "initialize":
            return await self.handle_initialize(params)
        elif method == "execute":
            return await self.handle_execute(params)
        elif method == "describe":
            return await self.handle_describe(params)
        else:
            return {
                "error": {
                    "code": -32601,
                    "message": f"Method not found: {method}"
                }
            }
    
    async def handle_initialize(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Handle initialization request"""
        return {
            "result": {
                "name": "{{ tool_name }}",
                "version": "{{ version }}",
                "capabilities": self.capabilities,
                "protocol_version": "{{ protocol_version }}"
            }
        }
    
    async def handle_execute(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Handle execution request"""
        # TODO: Implement actual tool execution
        command = params.get("command", "")
        args = params.get("args", {})
        
        # Execute tool logic here
        result = await self.execute_tool(command, args)
        
        return {"result": result}
    
    async def handle_describe(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Handle describe request"""
        return {
            "result": {
                "description": "{{ description }}",
                "parameters": {{ parameters | tojson }},
                "examples": []
            }
        }
    
    async def execute_tool(self, command: str, args: Dict[str, Any]) -> Any:
        """Execute the actual tool logic"""
        # TODO: Implement your tool logic here
        return {
            "status": "success",
            "output": f"Executed {command} with args {args}"
        }
    
    async def handle_client(self, websocket, path):
        """Handle WebSocket client connection"""
        self.clients.add(websocket)
        try:
            async for message in websocket:
                try:
                    data = json.loads(message)
                    response = await self.handle_message(websocket, data)
                    response["id"] = data.get("id")
                    await websocket.send(json.dumps(response))
                except json.JSONDecodeError:
                    error_response = {
                        "error": {
                            "code": -32700,
                            "message": "Parse error"
                        }
                    }
                    await websocket.send(json.dumps(error_response))
                except Exception as e:
                    error_response = {
                        "error": {
                            "code": -32603,
                            "message": f"Internal error: {str(e)}"
                        }
                    }
                    await websocket.send(json.dumps(error_response))
        finally:
            self.clients.remove(websocket)
    
    async def start(self):
        """Start the MCP server"""
        print(f"Starting MCP server for {{ tool_name }} on {self.host}:{self.port}")
        async with websockets.serve(self.handle_client, self.host, self.port):
            await asyncio.Future()  # Run forever

if __name__ == "__main__":
    server = {{ tool_name | title | replace(' ', '') }}MCPServer()
    asyncio.run(server.start())
'''

        (template_dir / "mcp_server.py.j2").write_text(server_template)

        # MCP client template
        client_template = '''#!/usr/bin/env python3
"""
MCP Client for {{ tool_name }}
Generated by JARVIS MCP Integrator
"""

import asyncio
import json
import uuid
from typing import Dict, Any, Optional
import websockets

class {{ tool_name | title | replace(' ', '') }}MCPClient:
    """MCP client for {{ tool_name }}"""
    
    def __init__(self, server_url: str = "ws://localhost:8765"):
        self.server_url = server_url
        self.websocket: Optional[websockets.WebSocketClientProtocol] = None
        self.pending_requests = {}
    
    async def connect(self):
        """Connect to MCP server"""
        self.websocket = await websockets.connect(self.server_url)
        
        # Initialize connection
        response = await self.request("initialize", {
            "client_name": "{{ tool_name }}_client",
            "client_version": "{{ version }}"
        })
        
        return response.get("result", {})
    
    async def disconnect(self):
        """Disconnect from MCP server"""
        if self.websocket:
            await self.websocket.close()
    
    async def request(self, method: str, params: Dict[str, Any] = None) -> Dict[str, Any]:
        """Send request to MCP server"""
        if not self.websocket:
            raise RuntimeError("Not connected to MCP server")
        
        request_id = str(uuid.uuid4())
        request = {
            "id": request_id,
            "method": method,
            "params": params or {}
        }
        
        await self.websocket.send(json.dumps(request))
        
        # Wait for response
        response = await self.websocket.recv()
        return json.loads(response)
    
    async def execute(self, command: str, **kwargs) -> Any:
        """Execute a tool command"""
        response = await self.request("execute", {
            "command": command,
            "args": kwargs
        })
        
        if "error" in response:
            raise RuntimeError(f"Execution error: {response['error']['message']}")
        
        return response.get("result")
    
    async def describe(self) -> Dict[str, Any]:
        """Get tool description"""
        response = await self.request("describe")
        return response.get("result", {})

async def example_usage():
    """Example client usage"""
    client = {{ tool_name | title | replace(' ', '') }}MCPClient()
    
    try:
        # Connect to server
        info = await client.connect()
        print(f"Connected to: {info.get('name')} v{info.get('version')}")
        
        # Get description
        description = await client.describe()
        print(f"Description: {description}")
        
        # Execute command
        result = await client.execute("example_command", param1="value1")
        print(f"Result: {result}")
        
    finally:
        await client.disconnect()

if __name__ == "__main__":
    asyncio.run(example_usage())
'''

        (template_dir / "mcp_client.py.j2").write_text(client_template)

        # Dockerfile template
        dockerfile_template = """FROM python:3.9-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    git \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application
COPY . .

# Expose MCP port
EXPOSE 8765

# Set environment variables
{% for key, value in environment_variables.items() %}
ENV {{ key }}={{ value }}
{% endfor %}

# Run the MCP server
CMD ["python", "{{ entry_point }}"]
"""

        (template_dir / "Dockerfile.j2").write_text(dockerfile_template)

        # Package.json template for npm distribution
        package_template = """{
  "name": "@jarvis/{{ tool_name }}",
  "version": "{{ version }}",
  "description": "{{ description }}",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "test": "jest"
  },
  "keywords": {{ keywords | tojson }},
  "author": "{{ author }}",
  "license": "{{ license }}",
  "dependencies": {
    "ws": "^8.0.0"
  },
  "mcp": {
    "version": "{{ protocol_version }}",
    "capabilities": {{ capabilities | tojson }}
  }
}
"""

        (template_dir / "package.json.j2").write_text(package_template)

        # MCP manifest template
        manifest_template = """name: {{ tool_name }}
version: {{ version }}
protocol_version: {{ protocol_version }}
description: {{ description }}
author: {{ author }}
license: {{ license }}
{% if repository %}
repository: {{ repository }}
{% endif %}
{% if homepage %}
homepage: {{ homepage }}
{% endif %}

keywords:
{% for keyword in keywords %}
  - {{ keyword }}
{% endfor %}

categories:
{% for category in categories %}
  - {{ category }}
{% endfor %}

capabilities:
{% for capability, config in capabilities.items() %}
  {{ capability }}:
    {{ config | tojson }}
{% endfor %}

dependencies:
{% for dep, version in dependencies.items() %}
  {{ dep }}: "{{ version }}"
{% endfor %}

build_requirements:
{% for req in build_requirements %}
  - {{ req }}
{% endfor %}
"""

        (template_dir / "mcp.yaml.j2").write_text(manifest_template)

    async def create_mcp_tool(
        self, spec: MCPToolSpec, output_path: Optional[Path] = None
    ) -> Path:
        """Create a new MCP tool package"""
        mcp_tools_created.inc()

        # Create output directory
        if not output_path:
            output_path = self.workspace_path / "tools" / spec.name

        output_path.mkdir(parents=True, exist_ok=True)

        # Generate MCP server
        server_code = self.template_env.get_template("mcp_server.py.j2").render(
            tool_name=spec.name,
            version=spec.version,
            description=spec.description,
            capabilities=spec.capabilities,
            parameters=spec.parameters,
            protocol_version="1.0",
        )

        (output_path / "server.py").write_text(server_code)

        # Generate MCP client
        client_code = self.template_env.get_template("mcp_client.py.j2").render(
            tool_name=spec.name, version=spec.version
        )

        (output_path / "client.py").write_text(client_code)

        # Generate requirements.txt
        requirements = spec.requirements + [
            "websockets>=10.0",
            "aiohttp>=3.8.0",
            "pyyaml>=6.0",
        ]

        (output_path / "requirements.txt").write_text("\n".join(requirements))

        # Generate Dockerfile if Docker is enabled
        if self.docker_enabled and spec.docker_image:
            dockerfile = self.template_env.get_template("Dockerfile.j2").render(
                environment_variables=spec.environment_variables,
                entry_point="server.py",
            )

            (output_path / "Dockerfile").write_text(dockerfile)

        # Generate MCP manifest
        manifest = MCPManifest(
            tool_name=spec.name,
            version=spec.version,
            description=spec.description,
            author=spec.author,
            capabilities={cap: {} for cap in spec.capabilities},
            dependencies={"websockets": ">=10.0"},
        )

        manifest_yaml = self.template_env.get_template("mcp.yaml.j2").render(
            **manifest.__dict__
        )

        (output_path / "mcp.yaml").write_text(manifest_yaml)

        # Generate package.json for npm distribution
        package_json = self.template_env.get_template("package.json.j2").render(
            tool_name=spec.name.replace("_", "-"),
            version=spec.version,
            description=spec.description,
            author=spec.author,
            license="MIT",
            keywords=["mcp", "tool", spec.name],
            capabilities=spec.capabilities,
            protocol_version="1.0",
        )

        (output_path / "package.json").write_text(package_json)

        # Create README
        readme = f"""# {spec.name}

{spec.description}

## Installation

```bash
pip install -r requirements.txt
```

## Usage

### Starting the MCP server

```bash
python server.py
```

### Using the client

```python
from client import {spec.name.title().replace(' ', '')}MCPClient

client = {spec.name.title().replace(' ', '')}MCPClient()
await client.connect()
result = await client.execute("command", param="value")
```

## Capabilities

{', '.join(spec.capabilities)}

## Author

{spec.author}
"""

        (output_path / "README.md").write_text(readme)

        # Initialize git repository
        try:
            repo = git.Repo.init(output_path)
            repo.index.add("*")
            repo.index.commit("Initial MCP tool creation")
        except:
            logger.warning("Failed to initialize git repository")

        logger.info(f"Created MCP tool: {spec.name} at {output_path}")

        return output_path

    async def deploy_tool(
        self, tool_path: Path, deployment_type: str = "local"
    ) -> MCPDeployment:
        """Deploy an MCP tool"""
        # Load manifest
        manifest_path = tool_path / "mcp.yaml"
        if not manifest_path.exists():
            raise ValueError(f"MCP manifest not found at {manifest_path}")

        with open(manifest_path, "r") as f:
            manifest_data = yaml.safe_load(f)

        tool_name = manifest_data["name"]
        version = manifest_data["version"]

        # Generate deployment ID
        deployment_id = hashlib.sha256(
            f"{tool_name}{version}{datetime.now()}".encode()
        ).hexdigest()[:12]

        deployment = MCPDeployment(
            deployment_id=deployment_id,
            tool_name=tool_name,
            version=version,
            status="pending",
        )

        self.deployments[deployment_id] = deployment

        try:
            if deployment_type == "local":
                await self._deploy_local(tool_path, deployment)
            elif deployment_type == "docker" and self.docker_enabled:
                await self._deploy_docker(tool_path, deployment)
            else:
                raise ValueError(f"Unsupported deployment type: {deployment_type}")

            deployment.status = "running"
            mcp_deployments.labels(status="success").inc()
            mcp_active_servers.inc()

        except Exception as e:
            deployment.status = "failed"
            deployment.metadata["error"] = str(e)
            mcp_deployments.labels(status="failed").inc()
            logger.error(f"Deployment failed: {e}")
            raise

        return deployment

    async def _deploy_local(self, tool_path: Path, deployment: MCPDeployment):
        """Deploy tool locally"""
        # Install requirements
        requirements_path = tool_path / "requirements.txt"
        if requirements_path.exists():
            process = await asyncio.create_subprocess_exec(
                sys.executable,
                "-m",
                "pip",
                "install",
                "-r",
                str(requirements_path),
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            await process.wait()

        # Start server process
        server_path = tool_path / "server.py"
        process = await asyncio.create_subprocess_exec(
            sys.executable,
            str(server_path),
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )

        deployment.pid = process.pid
        deployment.server_url = "ws://localhost:8765"

        # Wait for server to start
        await asyncio.sleep(2)

        # Verify server is running
        try:
            async with websockets.connect(deployment.server_url) as ws:
                await ws.send(
                    json.dumps({"id": "test", "method": "initialize", "params": {}})
                )
                response = await ws.recv()
                logger.info(f"Server started successfully: {response}")
        except Exception as e:
            raise RuntimeError(f"Failed to connect to server: {e}")

    async def _deploy_docker(self, tool_path: Path, deployment: MCPDeployment):
        """Deploy tool in Docker container"""
        # Build Docker image
        image_tag = f"mcp-{deployment.tool_name}:{deployment.version}"

        self.docker_client.images.build(path=str(tool_path), tag=image_tag, rm=True)

        # Run container
        container = self.docker_client.containers.run(
            image_tag,
            detach=True,
            ports={"8765/tcp": None},  # Random host port
            environment=deployment.metadata.get("environment", {}),
            name=f"mcp-{deployment.deployment_id}",
        )

        deployment.container_id = container.id

        # Get assigned port
        container.reload()
        port = container.ports["8765/tcp"][0]["HostPort"]
        deployment.server_url = f"ws://localhost:{port}"

        # Wait for container to start
        await asyncio.sleep(3)

        # Verify container is running
        container.reload()
        if container.status != "running":
            raise RuntimeError(f"Container failed to start: {container.status}")

    async def stop_deployment(self, deployment_id: str):
        """Stop a deployment"""
        if deployment_id not in self.deployments:
            raise ValueError(f"Deployment not found: {deployment_id}")

        deployment = self.deployments[deployment_id]

        if deployment.pid:
            # Stop local process
            try:
                process = await asyncio.create_subprocess_exec(
                    "kill", str(deployment.pid)
                )
                await process.wait()
            except:
                logger.warning(f"Failed to stop process {deployment.pid}")

        if deployment.container_id and self.docker_enabled:
            # Stop Docker container
            try:
                container = self.docker_client.containers.get(deployment.container_id)
                container.stop()
                container.remove()
            except:
                logger.warning(f"Failed to stop container {deployment.container_id}")

        deployment.status = "stopped"
        mcp_active_servers.dec()

    async def connect_to_tool(
        self, deployment_id: str
    ) -> websockets.WebSocketClientProtocol:
        """Connect to a deployed tool"""
        if deployment_id not in self.deployments:
            raise ValueError(f"Deployment not found: {deployment_id}")

        deployment = self.deployments[deployment_id]

        if deployment.status != "running":
            raise RuntimeError(f"Deployment is not running: {deployment.status}")

        # Connect to WebSocket server
        ws = await websockets.connect(deployment.server_url)
        self.ws_connections[deployment_id] = ws

        return ws

    async def send_message(
        self, deployment_id: str, method: str, params: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """Send message to deployed tool"""
        if deployment_id not in self.ws_connections:
            ws = await self.connect_to_tool(deployment_id)
        else:
            ws = self.ws_connections[deployment_id]

        message = MCPMessage(id=str(uuid.uuid4()), method=method, params=params or {})

        await ws.send(
            json.dumps(
                {"id": message.id, "method": message.method, "params": message.params}
            )
        )

        response = await ws.recv()
        return json.loads(response)

    async def discover_tools(self) -> List[Dict[str, Any]]:
        """Discover available MCP tools"""
        tools = []

        # Scan local tools directory
        tools_dir = self.workspace_path / "tools"
        if tools_dir.exists():
            for tool_dir in tools_dir.iterdir():
                if tool_dir.is_dir():
                    manifest_path = tool_dir / "mcp.yaml"
                    if manifest_path.exists():
                        with open(manifest_path, "r") as f:
                            manifest = yaml.safe_load(f)
                            tools.append(
                                {
                                    "name": manifest["name"],
                                    "version": manifest["version"],
                                    "description": manifest.get("description", ""),
                                    "path": str(tool_dir),
                                    "source": "local",
                                }
                            )

        # Query registry if configured
        if self.registry_url:
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(f"{self.registry_url}/tools") as resp:
                        if resp.status == 200:
                            registry_tools = await resp.json()
                            for tool in registry_tools:
                                tool["source"] = "registry"
                                tools.append(tool)
            except Exception as e:
                logger.warning(f"Failed to query registry: {e}")

        return tools

    async def publish_tool(self, tool_path: Path, registry_url: Optional[str] = None):
        """Publish tool to registry"""
        registry_url = registry_url or self.registry_url

        if not registry_url:
            raise ValueError("No registry URL configured")

        # Load manifest
        manifest_path = tool_path / "mcp.yaml"
        with open(manifest_path, "r") as f:
            manifest = yaml.safe_load(f)

        # Create package
        package_data = {
            "name": manifest["name"],
            "version": manifest["version"],
            "description": manifest.get("description", ""),
            "author": manifest.get("author", ""),
            "manifest": manifest,
        }

        # Package files
        import tarfile
        import io

        tar_buffer = io.BytesIO()
        with tarfile.open(fileobj=tar_buffer, mode="w:gz") as tar:
            tar.add(tool_path, arcname=manifest["name"])

        tar_buffer.seek(0)

        # Upload to registry
        async with aiohttp.ClientSession() as session:
            data = aiohttp.FormData()
            data.add_field("metadata", json.dumps(package_data))
            data.add_field(
                "package",
                tar_buffer,
                filename=f"{manifest['name']}-{manifest['version']}.tar.gz",
            )

            async with session.post(f"{registry_url}/publish", data=data) as resp:
                if resp.status != 200:
                    raise RuntimeError(f"Failed to publish: {await resp.text()}")

                result = await resp.json()
                logger.info(f"Published tool: {result}")

                return result

    def generate_client_sdk(self, tool_path: Path, language: str = "python") -> Path:
        """Generate client SDK for a tool"""
        # Load manifest
        manifest_path = tool_path / "mcp.yaml"
        with open(manifest_path, "r") as f:
            manifest = yaml.safe_load(f)

        sdk_path = tool_path / "sdk" / language
        sdk_path.mkdir(parents=True, exist_ok=True)

        if language == "python":
            # Generate Python SDK
            sdk_code = f'''"""
Auto-generated Python SDK for {manifest['name']}
"""

from typing import Dict, Any, Optional
import asyncio
from mcp_client import {manifest['name'].title().replace(' ', '')}MCPClient

class {manifest['name'].title().replace(' ', '')}SDK:
    """SDK for {manifest['name']}"""
    
    def __init__(self, server_url: str = "ws://localhost:8765"):
        self.client = {manifest['name'].title().replace(' ', '')}MCPClient(server_url)
        self._connected = False
    
    async def __aenter__(self):
        await self.connect()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.disconnect()
    
    async def connect(self):
        """Connect to the MCP server"""
        if not self._connected:
            await self.client.connect()
            self._connected = True
    
    async def disconnect(self):
        """Disconnect from the MCP server"""
        if self._connected:
            await self.client.disconnect()
            self._connected = False
'''

            # Add methods for each capability
            for capability in manifest.get("capabilities", {}):
                sdk_code += f'''
    
    async def {capability}(self, **kwargs) -> Any:
        """Execute {capability} capability"""
        return await self.client.execute("{capability}", **kwargs)
'''

            (sdk_path / "__init__.py").write_text(sdk_code)

        elif language == "javascript":
            # Generate JavaScript SDK
            sdk_code = f"""/**
 * Auto-generated JavaScript SDK for {manifest['name']}
 */

const WebSocket = require('ws');

class {manifest['name'].title().replace(' ', '')}SDK {{
    constructor(serverUrl = 'ws://localhost:8765') {{
        this.serverUrl = serverUrl;
        this.ws = null;
        this.requestId = 0;
        this.pendingRequests = {{}};
    }}
    
    async connect() {{
        return new Promise((resolve, reject) => {{
            this.ws = new WebSocket(this.serverUrl);
            
            this.ws.on('open', () => {{
                this.request('initialize', {{}}).then(resolve).catch(reject);
            }});
            
            this.ws.on('message', (data) => {{
                const response = JSON.parse(data);
                const request = this.pendingRequests[response.id];
                if (request) {{
                    delete this.pendingRequests[response.id];
                    if (response.error) {{
                        request.reject(new Error(response.error.message));
                    }} else {{
                        request.resolve(response.result);
                    }}
                }}
            }});
            
            this.ws.on('error', reject);
        }});
    }}
    
    disconnect() {{
        if (this.ws) {{
            this.ws.close();
        }}
    }}
    
    request(method, params = {{}}) {{
        return new Promise((resolve, reject) => {{
            const id = String(++this.requestId);
            this.pendingRequests[id] = {{ resolve, reject }};
            
            this.ws.send(JSON.stringify({{
                id,
                method,
                params
            }}));
        }});
    }}
"""

            # Add methods for capabilities
            for capability in manifest.get("capabilities", {}):
                sdk_code += f"""
    
    async {capability}(params = {{}}) {{
        return this.request('execute', {{
            command: '{capability}',
            args: params
        }});
    }}
"""

            sdk_code += (
                """
}

module.exports = """
                + manifest["name"].title().replace(" ", "")
                + """SDK;
"""
            )

            (sdk_path / "index.js").write_text(sdk_code)

            # Generate package.json
            package_json = {
                "name": f"@mcp/{manifest['name'].replace('_', '-')}-sdk",
                "version": manifest["version"],
                "description": f"SDK for {manifest['name']}",
                "main": "index.js",
                "dependencies": {"ws": "^8.0.0"},
            }

            (sdk_path / "package.json").write_text(json.dumps(package_json, indent=2))

        return sdk_path

    async def validate_tool(self, tool_path: Path) -> Dict[str, Any]:
        """Validate an MCP tool"""
        validation_results = {"valid": True, "errors": [], "warnings": []}

        # Check required files
        required_files = ["mcp.yaml", "server.py", "requirements.txt"]
        for file in required_files:
            if not (tool_path / file).exists():
                validation_results["errors"].append(f"Missing required file: {file}")
                validation_results["valid"] = False

        # Validate manifest
        manifest_path = tool_path / "mcp.yaml"
        if manifest_path.exists():
            try:
                with open(manifest_path, "r") as f:
                    manifest = yaml.safe_load(f)

                # Check required fields
                required_fields = ["name", "version", "protocol_version"]
                for field in required_fields:
                    if field not in manifest:
                        validation_results["errors"].append(
                            f"Missing required field in manifest: {field}"
                        )
                        validation_results["valid"] = False

                # Validate version format
                try:
                    semantic_version.Version(manifest.get("version", ""))
                except:
                    validation_results["errors"].append(
                        "Invalid version format (use semantic versioning)"
                    )
                    validation_results["valid"] = False

            except Exception as e:
                validation_results["errors"].append(f"Invalid manifest: {e}")
                validation_results["valid"] = False

        # Check Python syntax
        server_path = tool_path / "server.py"
        if server_path.exists():
            try:
                compile(server_path.read_text(), str(server_path), "exec")
            except SyntaxError as e:
                validation_results["errors"].append(
                    f"Python syntax error in server.py: {e}"
                )
                validation_results["valid"] = False

        return validation_results


# Example usage
async def example_usage():
    """Example of using the MCP Integrator"""
    integrator = MCPIntegrator()

    # Create a sample MCP tool
    spec = MCPToolSpec(
        name="example_calculator",
        version="1.0.0",
        description="A simple calculator MCP tool",
        author="JARVIS",
        capabilities=["add", "subtract", "multiply", "divide"],
        parameters={
            "add": {
                "a": {"type": "number", "required": True},
                "b": {"type": "number", "required": True},
            },
            "subtract": {
                "a": {"type": "number", "required": True},
                "b": {"type": "number", "required": True},
            },
        },
        requirements=["aiohttp>=3.8.0"],
        environment_variables={"LOG_LEVEL": "INFO"},
    )

    print("Creating MCP tool...")
    tool_path = await integrator.create_mcp_tool(spec)
    print(f"Tool created at: {tool_path}")

    # Validate tool
    print("\nValidating tool...")
    validation = await integrator.validate_tool(tool_path)
    print(f"Validation result: {validation}")

    # Generate SDK
    print("\nGenerating Python SDK...")
    sdk_path = integrator.generate_client_sdk(tool_path, "python")
    print(f"SDK generated at: {sdk_path}")

    # Deploy tool locally
    print("\nDeploying tool...")
    deployment = await integrator.deploy_tool(tool_path, "local")
    print(f"Deployment ID: {deployment.deployment_id}")
    print(f"Server URL: {deployment.server_url}")

    # Wait a bit for server to start
    await asyncio.sleep(3)

    # Test the deployed tool
    print("\nTesting deployed tool...")
    try:
        response = await integrator.send_message(deployment.deployment_id, "initialize")
        print(f"Initialize response: {response}")

        # Execute a command
        response = await integrator.send_message(
            deployment.deployment_id,
            "execute",
            {"command": "add", "args": {"a": 5, "b": 3}},
        )
        print(f"Execute response: {response}")

    finally:
        # Stop deployment
        print("\nStopping deployment...")
        await integrator.stop_deployment(deployment.deployment_id)

    # Discover tools
    print("\nDiscovering tools...")
    tools = await integrator.discover_tools()
    for tool in tools:
        print(f"  - {tool['name']} v{tool['version']} ({tool['source']})")


if __name__ == "__main__":
    asyncio.run(example_usage())
